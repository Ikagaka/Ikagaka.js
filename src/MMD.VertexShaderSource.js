(function() {

  MMD.VertexShaderSource = '\nuniform mat4 uMVMatrix; // model-view matrix (model -> view space)\nuniform mat4 uPMatrix; // projection matrix (view -> projection space)\nuniform mat4 uNMatrix; // normal matrix (inverse of transpose of model-view matrix)\n\nuniform mat4 uLightMatrix; // mvpdMatrix of light space (model -> display space)\n\nattribute vec3 aVertexNormal;\nattribute vec2 aTextureCoord;\nattribute float aVertexEdge; // 0 or 1. 1 if the vertex has an edge. (becuase we can\'t pass bool to attributes)\n\nattribute float aBoneWeight;\nattribute vec3 aVectorFromBone1;\nattribute vec3 aVectorFromBone2;\nattribute vec4 aBone1Rotation;\nattribute vec4 aBone2Rotation;\nattribute vec3 aBone1Position;\nattribute vec3 aBone2Position;\n\nattribute vec3 aMultiPurposeVector;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec2 vTextureCoord;\nvarying vec4 vLightCoord; // coordinate in light space; to be mapped onto shadow map\n\nuniform float uEdgeThickness;\nuniform bool uEdge;\n\nuniform bool uGenerateShadowMap;\n\nuniform bool uSelfShadow;\n\nuniform bool uAxis;\nuniform bool uCenterPoint;\n\nvec3 qtransform(vec4 q, vec3 v) {\n  return v + 2.0 * cross(cross(v, q.xyz) - q.w*v, q.xyz);\n}\n\nvoid main() {\n  vec3 position;\n  vec3 normal;\n\n  if (uAxis || uCenterPoint) {\n\n    position = aMultiPurposeVector;\n\n  } else {\n\n    float weight = aBoneWeight;\n    vec3 morph = aMultiPurposeVector;\n\n    position = qtransform(aBone1Rotation, aVectorFromBone1 + morph) + aBone1Position;\n    normal = qtransform(aBone1Rotation, aVertexNormal);\n\n    if (weight < 0.99) {\n      vec3 p2 = qtransform(aBone2Rotation, aVectorFromBone2 + morph) + aBone2Position;\n      vec3 n2 = qtransform(aBone2Rotation, normal);\n\n      position = mix(p2, position, weight);\n      normal = normalize(mix(n2, normal, weight));\n    }\n  }\n\n  // return vertex point in projection space\n  gl_Position = uPMatrix * uMVMatrix * vec4(position, 1.0);\n\n  if (uCenterPoint) {\n    gl_Position.z = 0.0; // always on top\n    gl_PointSize = 16.0;\n  }\n\n  if (uGenerateShadowMap || uAxis || uCenterPoint) return;\n\n  // for fragment shader\n  vTextureCoord = aTextureCoord;\n  vPosition = (uMVMatrix * vec4(position, 1.0)).xyz;\n  vNormal = (uNMatrix * vec4(normal, 1.0)).xyz;\n\n  if (uSelfShadow) {\n    vLightCoord = uLightMatrix * vec4(position, 1.0);\n  }\n\n  if (uEdge) {\n    vec4 pos = gl_Position;\n    vec4 pos2 = uPMatrix * uMVMatrix * vec4(position + normal, 1.0);\n    vec4 norm = normalize(pos2 - pos);\n    gl_Position = pos + norm * uEdgeThickness * aVertexEdge * pos.w; // scale by pos.w to prevent becoming thicker when zoomed\n    return;\n  }\n}\n';

}).call(this);
