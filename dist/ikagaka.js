!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Ikagaka=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var Ikagaka;

Ikagaka = (function() {
  function Ikagaka() {
    var hoge;
    hoge = 0;
  }

  return Ikagaka;

})();

if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
  module.exports = Ikagaka;
}

window["Ikagaka"] = Ikagaka;

require("ikagaka.nar.js");

require("ikagaka.shell.js");

require("ikagaka.balloon.js");

require("ikagaka.named.js");

require("ikagaka.sakurascriptplayer.js");

require("ikagaka.ghost.js");

},{"ikagaka.balloon.js":2,"ikagaka.ghost.js":4,"ikagaka.named.js":5,"ikagaka.nar.js":7,"ikagaka.sakurascriptplayer.js":8,"ikagaka.shell.js":9}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var Balloon;

Balloon = (function() {
  var $, BalloonSurface, Nar, SurfaceUtil, URL, _ref, _ref1, _ref2;

  $ = window["Zepto"];

  Nar = window["Nar"] || ((_ref = window["Ikagaka"]) != null ? _ref["Nar"] : void 0) || require("ikagaka.nar.js");

  SurfaceUtil = window["SurfaceUtil"] || ((_ref1 = window["Ikagaka"]) != null ? _ref1["SurfaceUtil"] : void 0);

  BalloonSurface = window["BalloonSurface"] || ((_ref2 = window["Ikagaka"]) != null ? _ref2["BalloonSurface"] : void 0) || require("./BalloonSurface.js");

  URL = window["URL"];

  function Balloon(directory) {
    var buffer;
    if (!directory["descript.txt"]) {
      throw new Error("descript.txt not found");
    }
    this.directory = directory;
    buffer = this.directory["descript.txt"].asArrayBuffer();
    this.descript = Nar.parseDescript(Nar.convert(buffer));
    this.balloons = {
      "sakura": [],
      "kero": [],
      "communicate": [],
      "online": [],
      "arrow": [],
      "sstp": null,
      "thumbnail": null
    };
  }

  Balloon.prototype.load = function(callback) {
    return Balloon.loadBalloonSurfaces(this.directory, this.balloons, (function(_this) {
      return function(err) {
        Balloon.loadBalloonDescripts(_this.directory, _this.balloons, _this.descript);
        return callback(err);
      };
    })(this));
  };

  Balloon.prototype.attachSurface = function(canvas, scopeId, surfaceId) {
    var type;
    type = scopeId === 0 ? "sakura" : "kero";
    if (!!this.balloons[type][surfaceId]) {
      return new BalloonSurface(canvas, scopeId, this.balloons[type][surfaceId], this.balloons);
    } else {
      return null;
    }
  };

  Balloon.loadBalloonDescripts = function(directory, balloons, descript) {
    Object.keys(directory).filter(function(filepath) {
      return /balloon([sk])(\d+)s\.txt$/.test(filepath);
    }).forEach(function(filepath) {
      var buffer, n, type, __, _descript, _ref3;
      buffer = directory[filepath].asArrayBuffer();
      _descript = Nar.parseDescript(Nar.convert(buffer));
      _ref3 = /balloon([sk])(\d+)s\.txt$/.exec(filepath), __ = _ref3[0], type = _ref3[1], n = _ref3[2];
      switch (type) {
        case "s":
          return balloons["sakura"][Number(n)].descript = $.extend(true, _descript, descript);
        case "k":
          return balloons["kero"][Number(n)].descript = $.extend(true, _descript, descript);
      }
    });
    return void 0;
  };

  Balloon.loadBalloonSurfaces = function(directory, balloons, callback) {
    var promises;
    promises = Object.keys(directory).filter(function(filepath) {
      return /[^\/]+\.png$/.test(filepath);
    }).map(function(filepath) {
      return new Promise(function(resolve, reject) {
        var buffer, url;
        buffer = directory[filepath].asArrayBuffer();
        url = URL.createObjectURL(new Blob([buffer], {
          type: "image/png"
        }));
        return SurfaceUtil.loadImage(url, function(err, img) {
          var n, type, __, _ref3, _ref4, _ref5;
          URL.revokeObjectURL(url);
          if (!!err) {
            return reject(err);
          }
          if (/^balloon([ksc])(\d+)\.png$/.test(filepath)) {
            _ref3 = /^balloon([ksc])(\d+)\.png$/.exec(filepath), __ = _ref3[0], type = _ref3[1], n = _ref3[2];
            switch (type) {
              case "s":
                balloons["sakura"][Number(n)] = {
                  canvas: SurfaceUtil.transImage(img)
                };
                break;
              case "k":
                balloons["kero"][Number(n)] = {
                  canvas: SurfaceUtil.transImage(img)
                };
                break;
              case "c":
                balloons["communicate"][Number(n)] = {
                  canvas: SurfaceUtil.transImage(img)
                };
            }
          } else if (/^online(\d+)\.png$/.test(filepath)) {
            _ref4 = /^online(\d+)\.png$/.exec(filepath), __ = _ref4[0], n = _ref4[1];
            balloons["online"][Number(n)] = {
              canvas: SurfaceUtil.transImage(img)
            };
          } else if (/^arrow(\d+)\.png$/.test(filepath)) {
            _ref5 = /^arrow(\d+)\.png$/.exec(filepath), __ = _ref5[0], n = _ref5[1];
            balloons["arrow"][Number(n)] = {
              canvas: SurfaceUtil.transImage(img)
            };
          } else if (/^sstp\.png$/.test(filepath)) {
            balloons["sstp"] = {
              canvas: SurfaceUtil.transImage(img)
            };
          } else if (/^thumbnail\.png$/.test(filepath)) {
            balloons["thumbnail"] = {
              canvas: SurfaceUtil.transImage(img)
            };
          }
          return resolve();
        });
      });
    });
    Promise.all(promises).then(function() {
      return callback(null);
    })["catch"](function(err) {
      console.error(err, err.stack);
      return callback(err);
    });
    return void 0;
  };

  return Balloon;

})();

if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
  module.exports = Balloon;
}

if (window["Ikagaka"] != null) {
  window["Ikagaka"]["Balloon"] = Balloon;
}

},{"./BalloonSurface.js":3,"ikagaka.nar.js":7}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var BalloonSurface;

BalloonSurface = (function() {
  var SurfaceUtil, _ref;

  SurfaceUtil = window["SurfaceUtil"] || ((_ref = window["Ikagaka"]) != null ? _ref["SurfaceUtil"] : void 0);

  function BalloonSurface(element, scopeId, balloonConf, balloons) {
    this.element = element;
    this.scopeId = scopeId;
    this.balloons = balloons;
    this.descript = balloonConf.descript;
    this.baseCanvas = balloonConf.canvas;
    this.render();
  }

  BalloonSurface.prototype.destructor = function() {
    $(this.element).off();
    return void 0;
  };

  BalloonSurface.prototype.render = function() {
    var type, util;
    type = this.scopeId === 0 ? "sakura" : "kero";
    util = new SurfaceUtil(this.element);
    util.init(this.baseCanvas);
    return void 0;
  };

  return BalloonSurface;

})();

if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
  module.exports = BalloonSurface;
}

if (window["Ikagaka"] != null) {
  window["Ikagaka"]["BalloonSurface"] = BalloonSurface;
}

},{}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
var Ghost;

Ghost = (function() {
  var Nar, Worker, _;

  _ = window["_"];

  Nar = window["Nar"] || window["Ikagaka"]["Nar"] || require("ikagaka.nar.js");

  Worker = window["Worker"];

  function Ghost(directory) {
    var buffer, descriptTxt;
    console.log(directory);
    if (!directory["descript.txt"]) {
      throw new Error("descript.txt not found");
    }
    this.directory = directory;
    buffer = this.directory["descript.txt"].asArrayBuffer();
    descriptTxt = Nar.convert(buffer);
    this.descript = Nar.parseDescript(descriptTxt);
    this.worker = null;
  }

  Ghost.prototype.path = "./";

  Ghost.prototype.logging = false;

  Ghost.prototype.load = function(callback) {
    var buffers, directory, _ref;
    if (!this.directory[this.descript["shiori"]] && !this.directory["shiori.dll"]) {
      return callback(new Error("shiori not found"));
    }
    console.log(this.path);
    switch (Ghost.detectShiori(this.directory)) {
      case "kawari":
        this.worker = new Worker(this.path + "KawariWorker.js");
        break;
      case "kawari7":
        this.worker = new Worker(this.path + "Kawari7Worker.js");
        break;
      case "satori":
        this.worker = new Worker(this.path + "SatoriWorker.js");
        break;
      case "yaya":
        this.worker = new Worker(this.path + "YAYAWorker.js");
        break;
      case "aya5":
        this.worker = new Worker(this.path + "AYA5Worker.js");
        break;
      case "miyojs":
        this.worker = new Worker(this.path + "MiyoJSWorker.js");
        break;
      default:
        return callback(new Error("cannot detect shiori type: " + this.descript["shiori"]));
    }
    _ref = Ghost.createTransferable(this.directory), directory = _ref.directory, buffers = _ref.buffers;
    this.worker.addEventListener("error", function(ev) {
      return console.error(ev.error);
    });
    this.worker.postMessage({
      event: "load",
      data: directory
    }, buffers);
    this.worker.onmessage = function(_arg) {
      var error, event, _ref1;
      _ref1 = _arg.data, event = _ref1.event, error = _ref1.error;
      if (event === "loaded") {
        return callback(error);
      }
    };
    return void 0;
  };

  Ghost.prototype.request = function(request, callback) {
    if (this.logging) {
      console.log(request);
    }
    this.worker.postMessage({
      event: "request",
      data: request
    });
    this.worker.onmessage = (function(_this) {
      return function(_arg) {
        var error, event, response, _ref;
        _ref = _arg.data, event = _ref.event, error = _ref.error, response = _ref.data;
        if (_this.logging) {
          console.log(response);
        }
        if (event === "response") {
          return callback(error, response);
        }
      };
    })(this);
    return void 0;
  };

  Ghost.prototype.unload = function(callback) {
    this.worker.postMessage({
      event: "unload"
    });
    this.worker.onmessage = function(_arg) {
      var error, event, _ref;
      _ref = _arg.data, event = _ref.event, error = _ref.error;
      if (event === "unloaded") {
        return callback(error);
      }
    };
    return void 0;
  };

  Ghost.detectShiori = function(directory) {
    if (!!directory["kawarirc.kis"]) {
      return "kawari";
    }
    if (!!directory["kawari.ini"]) {
      return "kawari7";
    }
    if (!!directory["satori_conf.txt"]) {
      return "satori";
    }
    if (!!directory["yaya.dll"]) {
      return "yaya";
    }
    if (!!directory["aya5.dll"]) {
      return "aya5";
    }
    if (!!directory["node.exe"]) {
      return "miyojs";
    }
    return "";
  };

  Ghost.createTransferable = function(_directory) {
    return Object.keys(_directory).filter(function(filepath) {
      return !!filepath;
    }).reduce((function(_arg, filepath) {
      var buffer, buffers, directory;
      directory = _arg.directory, buffers = _arg.buffers;
      buffer = _directory[filepath].asArrayBuffer();
      directory[filepath] = buffer;
      buffers.push(buffer);
      return {
        directory: directory,
        buffers: buffers
      };
    }), {
      directory: {},
      buffers: []
    });
  };

  return Ghost;

})();

if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
  module.exports = Ghost;
}

if (window["Ikagaka"] != null) {
  window["Ikagaka"]["Ghost"] = Ghost;
}

},{"ikagaka.nar.js":7}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var Named;

Named = (function() {
  var $, Scope, prompt, _ref;

  $ = window["Zepto"];

  Scope = window["Scope"] || ((_ref = window["Ikagaka"]) != null ? _ref["Scope"] : void 0) || require("./Scope.js");

  prompt = window["prompt"];

  function Named(shell, balloon) {
    this.shell = shell;
    this.balloon = balloon;
    this.$named = $("<div />").addClass("named");
    this.element = this.$named[0];
    this.scopes = [];
    this.scopes[0] = new Scope(0, this.shell, this.balloon);
    this.currentScope = this.scopes[0];
    this.destructors = [];
    (function(_this) {
      return (function() {
        var $body, $target, onmousedown, onmousemove, onmouseup, relLeft, relTop;
        $target = null;
        relLeft = relTop = 0;
        onmouseup = function(ev) {
          var _ref1, _ref2;
          if (!!$target) {
            if ($(ev.target).hasClass("blimpText") || $(ev.target).hasClass("blimpCanvas")) {
              if ($target[0] === ((_ref1 = $(ev.target).parent()) != null ? _ref1[0] : void 0)) {
                return $target = null;
              }
            } else if ($(ev.target).hasClass("surfaceCanvas")) {
              if ($target[0] === ((_ref2 = $(ev.target).parent().parent()) != null ? _ref2[0] : void 0)) {
                return $target = null;
              }
            }
          }
        };
        onmousedown = function(ev) {
          var $scope, left, offsetX, offsetY, top, _ref1, _ref2, _ref3, _ref4;
          if ($(ev.target).hasClass("blimpText") || $(ev.target).hasClass("blimpCanvas")) {
            if (((_ref1 = $(ev.target).parent().parent().parent()) != null ? _ref1[0] : void 0) === _this.element) {
              $target = $(ev.target).parent();
              $scope = $target.parent();
              _ref2 = $target.offset(), top = _ref2.top, left = _ref2.left;
              offsetY = parseInt($target.css("left"), 10);
              offsetX = parseInt($target.css("top"), 10);
              relLeft = ev.pageX - offsetY;
              relTop = ev.pageY - offsetX;
              return setTimeout((function() {
                return _this.$named.append($scope);
              }), 100);
            }
          } else if ($(ev.target).hasClass("surfaceCanvas")) {
            if (((_ref3 = $(ev.target).parent().parent().parent()) != null ? _ref3[0] : void 0) === _this.element) {
              $scope = $target = $(ev.target).parent().parent();
              _ref4 = $target.offset(), top = _ref4.top, left = _ref4.left;
              relLeft = ev.pageX - left;
              relTop = ev.pageY - top;
              return setTimeout((function() {
                return _this.$named.append($scope);
              }), 100);
            }
          }
        };
        onmousemove = function(ev) {
          if (!!$target) {
            return $target.css({
              left: ev.pageX - relLeft,
              top: ev.pageY - relTop
            });
          }
        };
        $body = $("body");
        $body.on("mouseup", onmouseup);
        $body.on("mousedown", onmousedown);
        $body.on("mousemove", onmousemove);
        return _this.destructors.push(function() {
          $body.off("mouseup", onmouseup);
          $body.off("mousedown", onmousedown);
          return $body.off("mousemove", onmousemove);
        });
      });
    })(this)();
    (function(_this) {
      return (function() {
        var onblimpclick;
        onblimpclick = function(ev) {};
        _this.$named.on("click", ".blimp", onblimpclick);
        return _this.destructors.push(function() {
          return _this.$named.off("click", ".blimp", onblimpclick);
        });
      });
    })(this)();
    (function(_this) {
      return (function() {
        var onanchorclick, onchoiceclick;
        onanchorclick = function(ev) {
          var detail;
          detail = {
            "ID": "OnChoiceSelect",
            "Reference0": ev.target.dataset["choiceid"]
          };
          return _this.$named.trigger($.Event("IkagakaSurfaceEvent", {
            detail: detail
          }));
        };
        onchoiceclick = function(ev) {
          var detail;
          detail = {
            "ID": "OnAnchorSelect",
            "Reference0": ev.target.dataset["anchorid"]
          };
          return _this.$named.trigger($.Event("IkagakaSurfaceEvent", {
            detail: detail
          }));
        };
        _this.$named.on("click", ".ikagaka-choice", onanchorclick);
        _this.$named.on("click", ".ikagaka-anchor", onchoiceclick);
        return _this.destructors.push(function() {
          _this.$named.off("click", ".ikagaka-choice", onanchorclick);
          return _this.$named.off("click", ".ikagaka-anchor", onchoiceclick);
        });
      });
    })(this)();
  }

  Named.prototype.destructor = function() {
    this.scopes.forEach(function(scope) {
      return $(scope.element).remove();
    });
    this.destructors.forEach(function(destructor) {
      return destructor();
    });
    return this.$named.remove();
  };

  Named.prototype.scope = function(scopeId) {
    if (!isFinite(scopeId)) {
      return this.currentScope;
    }
    if (!this.scopes[scopeId]) {
      this.scopes[scopeId] = new Scope(scopeId, this.shell, this.balloon);
    }
    this.currentScope = this.scopes[scopeId];
    this.$named.append(this.scopes[scopeId].element);
    return this.currentScope;
  };

  Named.prototype.openInputBox = function(id, text) {
    var detail;
    if (text == null) {
      text = "";
    }
    detail = {
      "ID": "OnUserInput",
      "Reference0": id,
      "Reference1": "" + prompt("UserInput", text)
    };
    return this.$named.trigger($.Event("IkagakaSurfaceEvent", {
      detail: detail
    }));
  };

  Named.prototype.openCommunicateBox = function(text) {
    var detail;
    if (text == null) {
      text = "";
    }
    detail = {
      "ID": "OnCommunicate",
      "Reference0": "user",
      "Reference1": "" + prompt("Communicate", text)
    };
    return this.$named.trigger($.Event("IkagakaSurfaceEvent", {
      detail: detail
    }));
  };

  return Named;

})();

if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
  module.exports = Named;
}

if (window["Ikagaka"] != null) {
  window["Ikagaka"]["Named"] = Named;
}

},{"./Scope.js":6}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var Scope;

Scope = (function() {
  var $;

  $ = window["Zepto"];

  function Scope(scopeId, shell, balloon) {
    var $style;
    this.scopeId = scopeId;
    this.shell = shell;
    this.balloon = balloon;
    this.$scope = $("<div />").addClass("scope");
    $style = $("<style scoped />").html(this.style);
    this.$surface = $("<div />").addClass("surface");
    this.$surfaceCanvas = $("<canvas />").addClass("surfaceCanvas");
    this.$blimp = $("<div />").addClass("blimp");
    this.$blimpCanvas = $("<canvas width='0' height='0' />").addClass("blimpCanvas");
    this.$blimpText = $("<div />").addClass("blimpText");
    this.$surface.append(this.$surfaceCanvas);
    this.$blimp.append(this.$blimpCanvas);
    this.$blimp.append(this.$blimpText);
    this.$scope.append($style);
    this.$scope.append(this.$surface);
    this.$scope.append(this.$blimp);
    this.element = this.$scope[0];
    this.destructors = [];
    this.currentSurface = null;
    this.currentBalloon = null;
    this.isBalloonLeft = true;
    this.talkInsertPointStack = [this.$blimpText];
    this.insertPoint = this.$blimpText;
    this.$scope.css({
      "bottom": "0px",
      "right": (this.scopeId * 240) + "px"
    });
  }

  Scope.prototype.surface = function(surfaceId, callback) {
    var type;
    if (callback == null) {
      callback = function() {};
    }
    type = this.scopeId === 0 ? "sakura" : "kero";
    if (surfaceId != null) {
      if (surfaceId === -1) {
        this.$surface.css({
          "visibility": "hidden"
        });
      } else {
        this.$surface.css({
          "visibility": "visible"
        });
      }
      if (!!this.currentSurface) {
        this.currentSurface.destructor();
      }
      this.currentSurface = this.shell.attachSurface(this.$surfaceCanvas[0], this.scopeId, surfaceId, callback);
      this.$scope.width(this.$surfaceCanvas.width());
      this.$scope.height(this.$surfaceCanvas.height());
    }
    return this.currentSurface;
  };

  Scope.prototype.blimp = function(balloonId, callback) {
    var b, descript, h, l, r, t, type, w;
    if (callback == null) {
      callback = function() {};
    }
    type = this.scopeId === 0 ? "sakura" : "kero";
    if (balloonId != null) {
      if (balloonId === -1) {
        this.$blimp.hide();
      } else {
        this.$blimp.show();
      }
      if (!!this.currentBalloon) {
        this.currentBalloon.destructor();
      }
      this.currentBalloon = this.balloon.attachSurface(this.$blimpCanvas[0], this.scopeId, balloonId);
      if (!!this.currentBalloon) {
        descript = this.currentBalloon.descript;
        this.$blimp.css({
          "width": this.$blimpCanvas.width(),
          "height": this.$blimpCanvas.height()
        });
        if (this.isBalloonLeft) {
          this.$blimp.css({
            "top": Number(this.shell.descript["" + type + ".balloon.offsety"] || 0),
            "left": Number(this.shell.descript["" + type + ".balloon.offsetx"] || 0) + -1 * this.$blimpCanvas.width()
          });
        } else {
          this.$blimp.css({
            "top": Number(this.shell.descript["" + type + ".balloon.offsety"] || 0),
            "left": Number(this.shell.descript["" + type + ".balloon.offsetx"] || 0) + this.$surfaceCanvas.width()
          });
        }
        if (this.$blimp.offset().top - this.$blimp.position().top >= $(window).height()) {
          this.$blimp.css({
            "top": -$(this.$blimpCanvas).height()
          });
        }
        t = descript["origin.y"] || descript["validrect.top"] || "10";
        r = descript["validrect.right"] || "10";
        b = descript["validrect.bottom"] || "10";
        l = descript["origin.x"] || descript["validrect.left"] || "10";
        w = this.$blimpCanvas.width();
        h = this.$blimpCanvas.height();
        this.$blimpText.css({
          "top": "" + t + "px",
          "left": "" + l + "px",
          "width": "" + (w - (Number(l) + Number(r))) + "px",
          "height": "" + (h - (Number(t) - Number(b))) + "px"
        });
      }
    }
    return {
      anchorBegin: (function(_this) {
        return function(id) {
          var _id;
          _id = $(document.createElement("div")).text(id).html();
          _this.insertPoint = $("<a />").addClass("ikagaka-anchor").attr({
            "data-anchorid": _id
          }).appendTo(_this.$blimpText);
          return void 0;
        };
      })(this),
      anchorEnd: (function(_this) {
        return function() {
          _this.insertPoint = _this.$blimpText;
          return void 0;
        };
      })(this),
      choice: (function(_this) {
        return function(text, id) {
          var _id, _text;
          _text = $(document.createElement("div")).text(text).html();
          _id = $(document.createElement("div")).text(id).html();
          $("<a />").addClass("ikagaka-choice").attr({
            "data-choiceid": _id
          }).html(_text).appendTo(_this.insertPoint);
          return void 0;
        };
      })(this),
      talk: (function(_this) {
        return function(text) {
          var _text;
          _text = $(document.createElement("div")).text(text).html();
          if (!!_this.currentSurface) {
            _this.currentSurface.talk();
          }
          _this.$blimp.show();
          _this.insertPoint.html(_this.insertPoint.html() + _text);
          _this.$blimpText[0].scrollTop = 999;
          return void 0;
        };
      })(this),
      clear: (function(_this) {
        return function() {
          _this.insertPoint = _this.$blimpText;
          _this.$blimpText.html("");
          return void 0;
        };
      })(this),
      br: (function(_this) {
        return function() {
          _this.insertPoint.html(_this.insertPoint.html() + "<br />");
          return void 0;
        };
      })(this)
    };
  };

  Scope.prototype.style = ".scope {\n  position: absolute;\n  pointer-events: none;\n  user-select: none;\n  -webkit-tap-highlight-color: transparent;\n}\n.surface {}\n.surfaceCanvas {\n  pointer-events: auto;\n}\n.blimp {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  pointer-events: auto;\n}\n.blimpCanvas {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n.blimpText {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  overflow-y: scroll;\n  white-space: pre;\n  white-space: pre-wrap;\n  white-space: pre-line;\n  word-wrap: break-word;\n}\n.blimpText a {\n  text-decoration: underline;\n  cursor: pointer;\n}\n.blimpText a:hover { background-color: yellow; }\n.blimpText a.ikagaka-choice { color: blue; }\n.blimpText a.ikagaka-anchor { color: red; }";

  return Scope;

})();

if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
  module.exports = Scope;
}

if (window["Ikagaka"] != null) {
  window["Ikagaka"]["Scope"] = Scope;
}

},{}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var Nar;

Nar = (function() {
  var Encoding, JSZip, URL, WMDescript, XMLHttpRequest;

  XMLHttpRequest = window["XHRProxy"];

  Encoding = window["Encoding"];

  JSZip = window["JSZip"];

  WMDescript = window["WMDescript"];

  URL = window["URL"];

  function Nar() {
    this.directory = null;
    this.install = null;
  }

  Nar.prototype.loadFromBuffer = function(buffer, callback) {
    this.directory = Nar.unzip(buffer);
    if (!this.directory["install.txt"]) {
      return callback(new Error("install.txt not found"));
    }
    return setTimeout((function(_this) {
      return function() {
        _this.install = Nar.parseDescript(Nar.convert(_this.directory["install.txt"].asArrayBuffer()));
        return callback(null);
      };
    })(this));
  };

  Nar.prototype.loadFromURL = function(src, callback) {
    return Nar.wget(src, "arraybuffer", (function(_this) {
      return function(err, buffer) {
        if (!!err) {
          return callback(err);
        }
        return _this.loadFromBuffer(buffer, callback);
      };
    })(this));
  };

  Nar.prototype.loadFromBlob = function(blob, callback) {
    var url;
    url = URL.createObjectURL(blob);
    return this.loadFromURL(url, function(err) {
      URL.revokeObjectURL(url);
      return callback(err);
    });
  };

  Nar.prototype.grep = function(regexp) {
    return Object.keys(this.directory).filter(function(path) {
      return regexp.test(path);
    });
  };

  Nar.prototype.getDirectory = function(regexp) {
    return this.grep(regexp).reduce(((function(_this) {
      return function(dir, path, zip) {
        dir[path.replace(regexp, "")] = _this.directory[path];
        return dir;
      };
    })(this)), {});
  };

  Nar.unzip = function(buffer) {
    var zip;
    zip = new JSZip();
    zip.load(buffer);
    return Object.keys(zip.files).reduce((function(dic, filePath) {
      var path;
      path = filePath.split("\\").join("/");
      dic[path] = zip.files[filePath];
      return dic;
    }), {});
  };

  Nar.convert = function(buffer) {
    return Encoding.codeToString(Encoding.convert(new Uint8Array(buffer), 'UNICODE', 'AUTO'));
  };

  Nar.wget = function(url, type, callback) {
    var xhr;
    xhr = new XMLHttpRequest();
    xhr.addEventListener("load", function() {
      if (200 <= xhr.status && xhr.status < 300) {
        if (!!xhr.response.error) {
          return callback(new Error(xhr.response.error.message), null);
        } else {
          return callback(null, xhr.response);
        }
      } else {
        return callback(new Error(xhr.status), null);
      }
    });
    xhr.open("GET", url);
    xhr.responseType = type;
    xhr.send();
    return void 0;
  };

  Nar.parseDescript = function(text) {
    return WMDescript.parse(text);
  };

  return Nar;

})();

if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
  module.exports = Nar;
}

if (window["Ikagaka"] != null) {
  window["Ikagaka"]["Nar"] = Nar;
}

},{}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var SakuraScriptPlayer;

SakuraScriptPlayer = (function() {
  function SakuraScriptPlayer(named) {
    this.named = named;
    this.playing = false;
    this.breakTid = 0;
    this.timeCritical = false;
  }

  SakuraScriptPlayer.prototype.play = function(script, callback) {
    var quick, recur, reg, wait;
    if (callback == null) {
      callback = function() {};
    }
    if (this.playing && this.timeCritical) {
      setTimeout(function() {
        return callback(true);
      });
      return;
    }
    this["break"]();
    this.playing = true;
    this.timeCritical = false;
    quick = false;
    wait = 80;
    reg = {
      "Y0": /^\\0/,
      "Y1": /^\\1/,
      "Yh": /^\\h/,
      "Yu": /^\\u/,
      "Yp": /^\\p\[(\d+)\]/,
      "Ypn": /^\\p(\d)/,
      "Ysn": /^\\s(\d)/,
      "Ys": /^\\s\[([^\]]+)\]/,
      "Yb": /^\\b\[([^\]]+)\]/,
      "Yi": /^\\i\[(\d+)\]/,
      "YwN": /^\\w(\d+)/,
      "Y_w": /^\\\_w\[(\d+)\]/,
      "Y_q": /^\\\_q/,
      "Yt": /^\\t/,
      "Yx": /^\\x/,
      "Yq": /^\\q\[([^\]]+)\]/,
      "Y_aB": /^\\_a\[([^\]]+)\]/,
      "Y_aE": /^\\_a/,
      "YnH": /^\\n\[half\]/,
      "Yn": /^\\n/,
      "Yc": /^\\c/,
      "Ye": /^\\e/,
      "YY": /^\\\\/,
      "Ycom": /^\\\!\[\s*open\s*\,\s*communicatebox\s*\]/,
      "Yinp": /^\\\!\[\s*open\s*\,\s*inputbox\s*\,([^\]]+)\]/
    };
    (recur = (function(_this) {
      return function() {
        var id, title, _ref, _script;
        if (script.length === 0) {
          _this.playing = false;
          _this.breakTid = setTimeout((function() {
            return _this["break"]();
          }), 10000);
          return;
        }
        wait = 80;
        switch (true) {
          case reg["Y0"].test(script):
            _script = script.replace(reg["Y0"], "");
            _this.named.scope(0).blimp(0);
            break;
          case reg["Y1"].test(script):
            _script = script.replace(reg["Y1"], "");
            _this.named.scope(1).blimp(0);
            break;
          case reg["Yh"].test(script):
            _script = script.replace(reg["Yh"], "");
            _this.named.scope(0).blimp(0);
            break;
          case reg["Yu"].test(script):
            _script = script.replace(reg["Yu"], "");
            _this.named.scope(1).blimp(0);
            break;
          case reg["Yp"].test(script):
            _script = script.replace(reg["Yp"], "");
            _this.named.scope(Number(reg["Yp"].exec(script)[1]));
            break;
          case reg["Ypn"].test(script):
            _script = script.replace(reg["Ypn"], "");
            _this.named.scope(Number(reg["Ypn"].exec(script)[1]));
            break;
          case reg["Ysn"].test(script):
            _script = script.replace(reg["Ysn"], "");
            _this.named.scope().surface(Number(reg["Ysn"].exec(script)[1]));
            break;
          case reg["Ys"].test(script):
            _script = script.replace(reg["Ys"], "");
            _this.named.scope().surface(Number(reg["Ys"].exec(script)[1]));
            break;
          case reg["Yb"].test(script):
            _script = script.replace(reg["Yb"], "");
            _this.named.scope().blimp(Number(reg["Yb"].exec(script)[1]));
            break;
          case reg["Yi"].test(script):
            _script = script.replace(reg["Yi"], "");
            _this.named.scope().surface().playAnimation(Number(reg["Yi"].exec(script)[1]));
            break;
          case reg["Y_q"].test(script):
            _script = script.replace(reg["Y_q"], "");
            quick = !quick;
            break;
          case reg["YwN"].test(script):
            _script = script.replace(reg["YwN"], "");
            wait = Number(reg["YwN"].exec(script)[1]) * 100;
            break;
          case reg["Y_w"].test(script):
            _script = script.replace(reg["Y_w"], "");
            wait = Number(reg["Y_w"].exec(script)[1]);
            break;
          case reg["Yt"].test(script):
            _script = script.replace(reg["Yt"], "");
            _this.timeCritical = true;
            break;
          case reg["Yq"].test(script):
            _script = script.replace(reg["Yq"], "");
            _ref = reg["Yq"].exec(script)[1].split(",", 2), title = _ref[0], id = _ref[1];
            _this.named.scope().blimp().choice(title, id);
            break;
          case reg["Y_aB"].test(script):
            _script = script.replace(reg["Y_aB"], "");
            id = reg["Y_aB"].exec(script)[1];
            _this.named.scope().blimp().anchorBegin(id);
            break;
          case reg["Y_aE"].test(script):
            _script = script.replace(reg["Y_aE"], "");
            _this.named.scope().blimp().anchorEnd();
            break;
          case reg["YnH"].test(script):
            _script = script.replace(reg["YnH"], "");
            _this.named.scope().blimp().br();
            break;
          case reg["Yn"].test(script):
            _script = script.replace(reg["Yn"], "");
            _this.named.scope().blimp().br();
            break;
          case reg["Yc"].test(script):
            _script = script.replace(reg["Yc"], "");
            _this.named.scope().blimp().clear();
            break;
          case reg["Ye"].test(script):
            _script = "";
            _this.named.scopes.forEach(function(scope) {
              var _ref1;
              return (_ref1 = scope.surface()) != null ? _ref1.YenE() : void 0;
            });
            break;
          case reg["YY"].test(script):
            _script = script.replace(reg["YY"], "");
            _this.named.scope().blimp().talk("\\");
            break;
          case reg["Ycom"].test(script):
            _script = script.replace(reg["Ycom"], "");
            setTimeout((function() {
              return _this.named.openCommunicateBox();
            }), 2000);
            break;
          case reg["Yinp"].test(script):
            _script = script.replace(reg["Yinp"], "");
            id = reg["Yinp"].exec(script)[1].split(/\s*\,\s*/)[0];
            setTimeout((function() {
              return _this.named.openInputBox(id);
            }), 2000);
            break;
          default:
            _script = script.slice(1);
            _this.named.scope().blimp().talk(script[0]);
        }
        script = _script;
        wait = (quick ? 0 : wait);
        return _this.breakTid = setTimeout(recur, wait);
      };
    })(this))();
    return void 0;
  };

  SakuraScriptPlayer.prototype["break"] = function() {
    this.playing = false;
    this.timeCritical = false;
    clearTimeout(this.breakTid);
    this.named.scopes.forEach(function(scope) {
      return scope.blimp(-1).clear();
    });
    return void 0;
  };

  return SakuraScriptPlayer;

})();

if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
  module.exports = SakuraScriptPlayer;
}

if (window["Ikagaka"] != null) {
  window["Ikagaka"]["SakuraScriptPlayer"] = SakuraScriptPlayer;
}

},{}],9:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var Shell;

Shell = (function() {
  var $, Nar, Promise, Surface, SurfaceUtil, SurfacesTxt2Yaml, URL, _, _ref, _ref1, _ref2;

  _ = window["_"];

  $ = window["Zepto"];

  SurfacesTxt2Yaml = window["SurfacesTxt2Yaml"];

  Nar = window["Nar"] || ((_ref = window["Ikagaka"]) != null ? _ref["Nar"] : void 0) || require("ikagaka.nar.js");

  Surface = window["Surface"] || ((_ref1 = window["Ikagaka"]) != null ? _ref1["Surface"] : void 0) || require("./Surface.js");

  SurfaceUtil = window["SurfaceUtil"] || ((_ref2 = window["Ikagaka"]) != null ? _ref2["SurfaceUtil"] : void 0) || require("./SurfaceUtil.js");

  Promise = window["Promise"];

  URL = window["URL"];

  function Shell(directory) {
    if (!directory["descript.txt"]) {
      throw new Error("descript.txt not found");
    }
    this.directory = directory;
    this.descript = Nar.parseDescript(Nar.convert(this.directory["descript.txt"].asArrayBuffer()));
    this.surfaces = null;
  }

  Shell.prototype.load = function(callback) {
    var buffer, mergedSurfaces, surfaces, surfacesTxt;
    if (!!this.directory["surfaces.txt"]) {
      buffer = this.directory["surfaces.txt"].asArrayBuffer();
      surfacesTxt = Nar.convert(buffer);
      surfaces = Shell.parseSurfaces(surfacesTxt);
    } else {
      surfaces = {
        "surfaces": {}
      };
    }
    mergedSurfaces = Shell.mergeSurfacesAndSurfacesFiles(surfaces, this.directory);
    return Shell.loadSurfaces(mergedSurfaces, (function(_this) {
      return function(err, loadedSurfaces) {
        return Shell.loadElements(loadedSurfaces, _this.directory, function(err, loadedElmSurfaces) {
          if (!!err) {
            return callback(err);
          }
          _this.surfaces = Shell.createBases(loadedElmSurfaces);
          return callback(null);
        });
      };
    })(this));
  };

  Shell.prototype.attachSurface = function(canvas, scopeId, surfaceId, callback) {
    var hits, srfs, type, _ref3, _ref4, _surfaceId;
    if (callback == null) {
      callback = function() {};
    }
    type = scopeId === 0 ? "sakura" : "kero";
    if (Array.isArray((_ref3 = this.surfaces.aliases) != null ? (_ref4 = _ref3[type]) != null ? _ref4[surfaceId] : void 0 : void 0)) {
      _surfaceId = SurfaceUtil.choice(this.surfaces.aliases[type][surfaceId]);
    } else {
      _surfaceId = surfaceId;
    }
    srfs = this.surfaces.surfaces;
    hits = Object.keys(srfs).filter(function(name) {
      return srfs[name].is === _surfaceId;
    });
    if (hits.length === 0) {
      return null;
    }
    return new Surface(canvas, scopeId, hits[0], this.surfaces, callback);
  };

  Shell.createBases = function(surfaces) {
    var srfs;
    srfs = surfaces.surfaces;
    Object.keys(srfs).forEach(function(name) {
      var baseSurface, cnv, elms, sortedElms, srfutil;
      if (!srfs[name].baseSurface) {
        cnv = document.createElement("canvas");
        cnv.width = 0;
        cnv.height = 0;
        srfs[name].baseSurface = cnv;
      }
      cnv = srfs[name].baseSurface;
      if (!srfs[name].elements) {
        return srfs[name].baseSurface = cnv;
      } else {
        elms = srfs[name].elements;
        sortedElms = Object.keys(elms).map(function(key) {
          return {
            is: elms[key].is,
            x: elms[key].x,
            y: elms[key].y,
            canvas: elms[key].canvas,
            type: elms[key].type
          };
        }).sort(function(elmA, elmB) {
          if (elmA.is > elmB.is) {
            return 1;
          } else {
            return -1;
          }
        });
        baseSurface = sortedElms[0].canvas || srfs[name].baseSurface;
        srfutil = new SurfaceUtil(baseSurface);
        srfutil.composeElements(sortedElms);
        return srfs[name].baseSurface = baseSurface;
      }
    });
    return surfaces;
  };

  Shell.loadSurfaces = function(surfaces, callback) {
    var promises, srfs;
    srfs = surfaces.surfaces;
    promises = Object.keys(srfs).filter(function(name) {
      return !!srfs[name].file;
    }).map(function(name) {
      return new Promise(function(resolve, reject) {
        return setTimeout(function() {
          var buffer, url;
          buffer = srfs[name].file.asArrayBuffer();
          url = URL.createObjectURL(new Blob([buffer], {
            type: "image/png"
          }));
          return SurfaceUtil.loadImage(url, function(err, img) {
            URL.revokeObjectURL(url);
            if (!!err) {
              return reject(err);
            }
            srfs[name].baseSurface = SurfaceUtil.transImage(img);
            return resolve();
          });
        });
      });
    });
    Promise.all(promises).then(function() {
      return callback(null, surfaces);
    })["catch"](function(err) {
      console.error(err, err.stack);
      return callback(err, null);
    });
    return void 0;
  };

  Shell.loadElements = function(surfaces, directory, callback) {
    var promises, srfs;
    srfs = surfaces.surfaces;
    promises = Object.keys(srfs).filter(function(name) {
      return !!srfs[name].elements;
    }).reduce((function(arr, srfName) {
      return arr.concat(Object.keys(srfs[srfName].elements).map(function(elmName) {
        var elm;
        elm = srfs[srfName].elements[elmName];
        return new Promise(function(resolve, reject) {
          return setTimeout(function() {
            var buffer, file, type, url, x, y;
            type = elm.type, file = elm.file, x = elm.x, y = elm.y;
            if (!directory[file]) {
              file += ".png";
            }
            if (!directory[file]) {
              reject(new Error(file.substr(0, file.length - 4) + "element file not found"));
            }
            buffer = directory[file].asArrayBuffer();
            url = URL.createObjectURL(new Blob([buffer], {
              type: "image/png"
            }));
            return SurfaceUtil.loadImage(url, function(err, img) {
              URL.revokeObjectURL(url);
              if (!!err) {
                return reject(err.error);
              }
              elm.canvas = SurfaceUtil.transImage(img);
              return resolve();
            });
          });
        });
      }));
    }), []);
    Promise.all(promises).then(function() {
      return callback(null, surfaces);
    })["catch"](function(err) {
      console.error(err, err.stack);
      return callback(err, null);
    });
    return void 0;
  };

  Shell.mergeSurfacesAndSurfacesFiles = function(surfaces, directory) {
    var srfs;
    srfs = surfaces.surfaces;
    return Object.keys(directory).filter(function(filename) {
      return /^surface\d+\.png$/i.test(filename);
    }).map(function(filename) {
      return [Number((/^surface(\d+)\.png$/i.exec(filename) || ["", "-1"])[1]), directory[filename]];
    }).reduce((function(surfaces, _arg) {
      var cnv, file, n, name;
      n = _arg[0], file = _arg[1];
      name = "surface" + n;
      if (!srfs[name]) {
        srfs[name] = {
          is: n
        };
      }
      srfs[name].file = file;
      cnv = document.createElement("canvas");
      cnv.width = 0;
      cnv.height = 0;
      srfs[name].baseSurface = cnv;
      return surfaces;
    }), surfaces);
  };

  Shell.parseSurfaces = function(text) {
    var data;
    data = SurfacesTxt2Yaml.txt_to_data(text, {
      compatible: 'ssp-lazy'
    });
    data.surfaces = Object.keys(data.surfaces).reduce((function(obj, name) {
      if (typeof data.surfaces[name].is !== "undefined") {
        obj[name] = data.surfaces[name];
      }
      if (Array.isArray(data.surfaces[name].base)) {
        data.surfaces[name].base.forEach(function(key) {
          return $.extend(true, data.surfaces[name], data.surfaces[key]);
        });
      }
      return obj;
    }), {});
    return data;
  };

  return Shell;

})();

if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
  module.exports = Shell;
}

if (window["Ikagaka"] != null) {
  window["Ikagaka"]["Shell"] = Shell;
}

},{"./Surface.js":10,"./SurfaceUtil.js":11,"ikagaka.nar.js":7}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var Surface;

Surface = (function() {
  var $, Promise, SurfaceUtil, _, _ref;

  $ = window["Zepto"];

  _ = window["_"];

  SurfaceUtil = window["SurfaceUtil"] || ((_ref = window["Ikagaka"]) != null ? _ref["SurfaceUtil"] : void 0) || require("./SurfaceUtil.js");

  Promise = window["Promise"];

  function Surface(element, scopeId, surfaceName, surfaces, callback) {
    var srf;
    this.element = element;
    this.scopeId = scopeId;
    this.surfaceName = surfaceName;
    this.surfaces = surfaces;
    if (callback == null) {
      callback = function() {};
    }
    srf = this.surfaces.surfaces[surfaceName];
    this.baseSurface = srf.baseSurface;
    this.regions = srf.regions || {};
    this.animations = srf.animations || {};
    this.bufferCanvas = SurfaceUtil.copy(this.baseSurface);
    this.stopFlags = {};
    this.layers = {};
    this.destructed = false;
    this.talkCount = 0;
    this.talkCounts = {};
    this.isPointerEventsShimed = false;
    this.lastEventType = "";
    $(this.element).on("contextmenu", (function(_this) {
      return function(ev) {
        return _this.processMouseEvent(ev, "OnMouseClick", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("click", (function(_this) {
      return function(ev) {
        return _this.processMouseEvent(ev, "OnMouseClick", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("dblclick", (function(_this) {
      return function(ev) {
        return _this.processMouseEvent(ev, "OnMouseDoubleClick", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("mousedown", (function(_this) {
      return function(ev) {
        return _this.processMouseEvent(ev, "OnMouseDown", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("mousemove", (function(_this) {
      return function(ev) {
        return _this.processMouseEvent(ev, "OnMouseMove", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("mouseup", (function(_this) {
      return function(ev) {
        return _this.processMouseEvent(ev, "OnMouseUp", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("touchmove", (function(_this) {
      return function(ev) {
        return _this.processMouseEvent(ev, "OnMouseMove", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("touchend", (function(_this) {
      return function(ev) {
        return _this.processMouseEvent(ev, "OnMouseUp", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("touchstart", (function(_this) {
      return function() {
        var touchOnce;
        touchOnce = false;
        return function(ev) {
          touchOnce = !touchOnce;
          if (touchOnce) {
            Surface.processMouseEvent(ev, _this.scopeId, _this.regions, "OnMouseDown", function($ev) {
              return $(_this.element).trigger($ev);
            });
            return setTimeout((function() {
              return touchOnce = false;
            }), 500);
          }
        };
      };
    })(this)());
    Object.keys(this.animations).forEach((function(_this) {
      return function(name) {
        var animationId, interval, n, pattern, tmp, _is, _ref1;
        _ref1 = _this.animations[name], _is = _ref1.is, interval = _ref1.interval, pattern = _ref1.pattern;
        animationId = _is;
        interval = interval || "";
        tmp = interval.split(",");
        interval = tmp[0];
        n = Number(tmp.slice(1).join(","));
        switch (interval) {
          case "sometimes":
            return Surface.random((function(callback) {
              if (!_this.destructed && !_this.stopFlags[animationId]) {
                return _this.play(animationId, callback);
              }
            }), 2);
          case "rarely":
            return Surface.random((function(callback) {
              if (!_this.destructed && !_this.stopFlags[animationId]) {
                return _this.play(animationId, callback);
              }
            }), 4);
          case "random":
            return Surface.random((function(callback) {
              if (!_this.destructed && !_this.stopFlags[animationId]) {
                return _this.play(animationId, callback);
              }
            }), n);
          case "periodic":
            return Surface.periodic((function(callback) {
              if (!_this.destructed && !_this.stopFlags[animationId]) {
                return _this.play(animationId, callback);
              }
            }), n);
          case "always":
            return Surface.always(function(callback) {
              if (!_this.destructed && !_this.stopFlags[animationId]) {
                return _this.play(animationId, callback);
              }
            });
          case "runonce":
            return _this.play(animationId, callback);
          case "never":
            break;
          case "bind":
            break;
          case "yen-e":
            break;
          case "talk":
            return _this.talkCounts[name] = n;
          default:
            if (/^bind(?:\+(\d+))/.test(interval)) {

            }
            return console.error(_this.animations[name]);
        }
      };
    })(this));
    this.render();
  }

  Surface.prototype.destructor = function() {
    SurfaceUtil.clear(this.element);
    $(this.element).off();
    this.destructed = true;
    this.layers = {};
    return void 0;
  };

  Surface.prototype.YenE = function() {
    return Object.keys(this.animations).filter((function(_this) {
      return function(name) {
        return _this.animations[name].interval === "yen-e" && _this.talkCount % _this.talkCounts[name] === 0;
      };
    })(this)).forEach((function(_this) {
      return function(name) {
        return _this.play(_this.animations[name].is);
      };
    })(this));
  };

  Surface.prototype.talk = function() {
    this.talkCount++;
    return Object.keys(this.animations).filter((function(_this) {
      return function(name) {
        return /^talk/.test(_this.animations[name].interval) && _this.talkCount % _this.talkCounts[name] === 0;
      };
    })(this)).forEach((function(_this) {
      return function(name) {
        return _this.play(_this.animations[name].is);
      };
    })(this));
  };

  Surface.prototype.render = function() {
    var patterns, srfs, util, util2;
    srfs = this.surfaces.surfaces;
    patterns = Object.keys(this.layers).sort(function(layerNumA, layerNumB) {
      if (Number(layerNumA) > Number(layerNumB)) {
        return 1;
      } else {
        return -1;
      }
    }).map((function(_this) {
      return function(key) {
        return _this.layers[key];
      };
    })(this)).reduce(((function(_this) {
      return function(arr, pat) {
        var hits, surface, type, x, y;
        surface = pat.surface, type = pat.type, x = pat.x, y = pat.y;
        if (surface === -1) {
          return arr;
        }
        hits = Object.keys(srfs).filter(function(key) {
          return srfs[key].is === surface;
        });
        if (hits.length === 0) {
          return arr;
        }
        return arr.concat({
          type: type,
          x: x,
          y: y,
          canvas: srfs[hits[hits.length - 1]].baseSurface
        });
      };
    })(this)), []);
    SurfaceUtil.clear(this.bufferCanvas);
    util = new SurfaceUtil(this.bufferCanvas);
    util.composeElements([
      {
        "type": "base",
        "canvas": this.baseSurface
      }
    ].concat(patterns));
    SurfaceUtil.clear(this.element);
    util2 = new SurfaceUtil(this.element);
    util2.init(this.bufferCanvas);
    return void 0;
  };

  Surface.prototype.play = function(animationId, callback) {
    var anim, hits;
    if (callback == null) {
      callback = function() {};
    }
    hits = Object.keys(this.animations).filter((function(_this) {
      return function(name) {
        return _this.animations[name].is === animationId;
      };
    })(this));
    if (hits.length === 0) {
      setTimeout(callback);
      return void 0;
    }
    anim = this.animations[hits[hits.length - 1]];
    anim.patterns.map((function(_this) {
      return function(pattern) {
        return function() {
          return new Promise(function(resolve, reject) {
            var a, animId, arr, b, match, surface, type, wait, __, _ref1, _ref2, _ref3;
            surface = pattern.surface, wait = pattern.wait, type = pattern.type;
            if (/^start\,\d+/.test(type)) {
              animId = Number(type.split(",")[1]);
              _this.play(animId, function() {
                return resolve();
              });
              return;
            }
            if (/^stop\,\d+/.test(type)) {
              animId = Number(type.split(",")[1]);
              _this.stop(animId, function() {
                return resolve();
              });
              return;
            }
            if (/^alternativestart\,[\(\[](\d+(?:\[\,\.]\d+)*)[\)\]]/.test(type)) {
              _ref1 = /^alternativestop\,[\(\[](\d+(?:\[\,\.]\d+)*)[\)\]]/.exec(type), __ = _ref1[0], match = _ref1[1];
              arr = match.split(/[\,\.]/);
              if (arr.length > 0) {
                animId = Number(SurfaceUtil.choice(arr));
                _this.play(animId, function() {
                  return resolve();
                });
                return;
              }
            }
            if (/^alternativestop\,[\(\[](\d+(?:\[\,\.]\d+)*)[\)\]]/.test(type)) {
              _ref2 = /^alternativestop\,[\(\[](\d+(?:\[\,\.]\d+)*)[\)\]]/.exec(type), __ = _ref2[0], match = _ref2[1];
              arr = match.split(/[\,\.]/);
              if (arr.length > 0) {
                animId = Number(SurfaceUtil.choice(arr));
                _this.stop(animId);
                resolve();
                return;
              }
            }
            _this.layers[anim.is] = pattern;
            _this.render();
            _ref3 = /(\d+)(?:\-(\d+))?/.exec(wait), __ = _ref3[0], a = _ref3[1], b = _ref3[2];
            if (!!b) {
              wait = _.random(Number(a), Number(b));
            }
            return setTimeout((function() {
              if (_this.destructed) {
                return reject();
              } else {
                return resolve();
              }
            }), wait);
          });
        };
      };
    })(this)).reduce((function(proA, proB) {
      return proA.then(proB);
    }), Promise.resolve()).then((function(_this) {
      return function() {
        return setTimeout(callback);
      };
    })(this))["catch"](function(err) {
      return console.error(err.stack);
    });
    return void 0;
  };

  Surface.prototype.stop = function(animationId) {
    this.stopFlags[animationId] = true;
    return void 0;
  };

  Surface.prototype.bind = function(animationId) {
    var anim, animIds, hits, interval, pattern;
    hits = Object.keys(this.animations).filter((function(_this) {
      return function(name) {
        return _this.animations[name].is === animationId;
      };
    })(this));
    if (hits.length === 0) {
      return void 0;
    }
    anim = this.animations[hits[hits.length - 1]];
    if (anim.patterns.length === 0) {
      return void 0;
    }
    interval = anim.interval;
    pattern = anim.patterns[anim.patterns.length - 1];
    this.layers[anim.is] = pattern;
    this.render();
    if (/^bind(?:\+(\d+))/.test(interval)) {
      animIds = interval.split("+").slice(1);
      animIds.forEach((function(_this) {
        return function(animId) {
          return _this.play(animId, function() {});
        };
      })(this));
    }
    return void 0;
  };

  Surface.prototype.unbind = function(animationId) {
    delete this.layers[animationId];
    return void 0;
  };

  Surface.prototype.processMouseEvent = function(ev, eventName, callback) {
    var detail, elm, hits, left, offsetX, offsetY, pageX, pageY, top, _ev, _ref1, _ref2;
    ev.preventDefault();
    $(ev.target).css({
      "cursor": "default"
    });
    if (this.isPointerEventsShimed && ev.type === this.lastEventType) {
      this.lastEventType = "";
      this.isPointerEventsShimed = false;
      ev.stopPropagation();
      return;
    }
    if (/^touch/.test(ev.type)) {
      _ref1 = ev.changedTouches[0], pageX = _ref1.pageX, pageY = _ref1.pageY;
    } else {
      pageX = ev.pageX, pageY = ev.pageY;
    }
    _ref2 = $(ev.target).offset(), left = _ref2.left, top = _ref2.top;
    offsetX = pageX - left;
    offsetY = pageY - top;
    if (Surface.isHit(ev.target, offsetX, offsetY)) {
      detail = {
        "ID": eventName,
        "Reference0": offsetX | 0,
        "Reference1": offsetY | 0,
        "Reference2": 0,
        "Reference3": this.scopeId,
        "Reference4": "",
        "Reference5": (ev.button === 2 ? 1 : 0)
      };
      hits = Object.keys(this.regions).sort(function(a, b) {
        if (a.is > b.is) {
          return 1;
        } else {
          return -1;
        }
      }).filter((function(_this) {
        return function(name) {
          var bottom, right, _ref3;
          _ref3 = _this.regions[name], name = _ref3.name, left = _ref3.left, top = _ref3.top, right = _ref3.right, bottom = _ref3.bottom;
          return ((left < offsetX && offsetX < right) && (top < offsetY && offsetY < bottom)) || ((right < offsetX && offsetX < left) && (bottom < offsetY && offsetY < top));
        };
      })(this));
      if (hits.length !== 0) {
        detail["Reference4"] = this.regions[hits[hits.length - 1]].name;
        $(ev.target).css({
          "cursor": "pointer"
        });
      }
      callback($.Event('IkagakaSurfaceEvent', {
        detail: detail,
        bubbles: true
      }));
    } else {
      ev.stopPropagation();
      this.isPointerEventsShimed = true;
      this.lastEventType = ev.type;
      $(ev.target).css({
        display: 'none'
      });
      elm = document.elementFromPoint(pageX, pageY);
      $(ev.target).css({
        display: 'inline-block'
      });
      _ev = document.createEvent(ev.constructor.name);
      if (typeof _ev.initMouseEvent === "function") {
        _ev.initMouseEvent(ev.type, ev.bubbles, ev.cancelable, ev.view, ev.detail, ev.screenX, ev.screenY, ev.clientX, ev.clientY, ev.ctrlKey, ev.altKey, ev.shiftKey, ev.metaKey, ev.button, ev.relatedTarget);
      }
      elm.dispatchEvent(_ev);
    }
    return void 0;
  };

  Surface.random = function(callback, n) {
    var ms;
    ms = 1;
    while (Math.round(Math.random() * 1000) > 1000 / n) {
      ms++;
    }
    return setTimeout((function() {
      return callback(function() {
        return Surface.random(callback, n);
      });
    }), ms * 1000);
  };

  Surface.periodic = function(callback, n) {
    return setTimeout((function() {
      return callback(function() {
        return Surface.periodic(callback, n);
      });
    }), n * 1000);
  };

  Surface.always = function(callback) {
    return callback(function() {
      return Surface.always(callback);
    });
  };

  Surface.isHit = function(canvas, x, y) {
    var ctx, data, imgdata;
    ctx = canvas.getContext("2d");
    imgdata = ctx.getImageData(0, 0, x + 1, y + 1);
    data = imgdata.data;
    return data[data.length - 1] !== 0;
  };

  return Surface;

})();

if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
  module.exports = Surface;
}

if (window["Ikagaka"] != null) {
  window["Ikagaka"]["Surface"] = Surface;
}

},{"./SurfaceUtil.js":11}],11:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var SurfaceUtil;

SurfaceUtil = (function() {
  function SurfaceUtil(cnv) {
    this.cnv = cnv;
    this.ctx = this.cnv.getContext("2d");
  }

  SurfaceUtil.prototype.composeElements = function(elements) {
    var canvas, copyed, offsetX, offsetY, type, x, y, _ref;
    if (elements.length === 0) {
      return;
    }
    _ref = elements[0], canvas = _ref.canvas, type = _ref.type, x = _ref.x, y = _ref.y;
    offsetX = offsetY = 0;
    switch (type) {
      case "base":
        this.base(canvas, offsetX, offsetY);
        break;
      case "overlay":
        this.overlayfast(canvas, offsetX + x, offsetY + y);
        break;
      case "overlayfast":
        this.overlayfast(canvas, offsetX + x, offsetY + y);
        break;
      case "replace":
        this.replace(canvas, offsetX + x, offsetY + y);
        break;
      case "add":
        this.overlayfast(canvas, offsetX + x, offsetY + y);
        break;
      case "bind":
        this.overlayfast(canvas, offsetX + x, offsetY + y);
        break;
      case "interpolate":
        this.interpolate(canvas, offsetX + x, offsetY + y);
        break;
      case "move":
        offsetX = x;
        offsetY = y;
        copyed = SurfaceUtil.copy(this.cnv);
        this.base(copyed, offsetX, offsetY);
        break;
      default:
        console.error(elements[0]);
    }
    this.composeElements(elements.slice(1));
    return void 0;
  };

  SurfaceUtil.prototype.base = function(part, x, y) {
    SurfaceUtil.clear(this.cnv);
    this.overlayfast(part, x, y);
    return void 0;
  };

  SurfaceUtil.prototype.overlayfast = function(part, x, y) {
    this.ctx.globalCompositeOperation = "source-over";
    this.ctx.drawImage(part, x, y);
    return void 0;
  };

  SurfaceUtil.prototype.interpolate = function(part, x, y) {
    this.ctx.globalCompositeOperation = "destination-over";
    this.ctx.drawImage(part, x, y);
    return void 0;
  };

  SurfaceUtil.prototype.replace = function(part, x, y) {
    this.ctx.clearRect(x, y, part.width, part.height);
    this.overlayfast(part, x, y);
    return void 0;
  };

  SurfaceUtil.prototype.init = function(cnv) {
    this.cnv.width = cnv.width;
    this.cnv.height = cnv.height;
    this.overlayfast(cnv, 0, 0);
    return void 0;
  };

  SurfaceUtil.choice = function(ary) {
    return ary[Math.round(Math.random() * (ary.length - 1))];
  };

  SurfaceUtil.clear = function(cnv) {
    cnv.width = cnv.width;
    return void 0;
  };

  SurfaceUtil.copy = function(cnv) {
    var copy, ctx;
    copy = document.createElement("canvas");
    ctx = copy.getContext("2d");
    copy.width = cnv.width;
    copy.height = cnv.height;
    ctx.drawImage(cnv, 0, 0);
    return copy;
  };

  SurfaceUtil.transImage = function(img) {
    var a, b, cnv, ctx, data, g, i, imgdata, r;
    cnv = SurfaceUtil.copy(img);
    ctx = cnv.getContext("2d");
    imgdata = ctx.getImageData(0, 0, img.width, img.height);
    data = imgdata.data;
    r = data[0], g = data[1], b = data[2], a = data[3];
    i = 0;
    if (a !== 0) {
      while (i < data.length) {
        if (r === data[i] && g === data[i + 1] && b === data[i + 2]) {
          data[i + 3] = 0;
        }
        i += 4;
      }
    }
    ctx.putImageData(imgdata, 0, 0);
    return cnv;
  };

  SurfaceUtil.loadImage = function(url, callback) {
    var img;
    img = new Image;
    img.src = url;
    img.addEventListener("load", function() {
      return callback(null, img);
    });
    img.addEventListener("error", function(ev) {
      console.error(ev);
      return callback(ev.error, null);
    });
    return void 0;
  };

  return SurfaceUtil;

})();

if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
  module.exports = SurfaceUtil;
}

if (window["Ikagaka"] != null) {
  window["Ikagaka"]["SurfaceUtil"] = SurfaceUtil;
}

},{}]},{},[1])(1)
});